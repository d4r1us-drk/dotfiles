#!/usr/bin/env bash

# ***This script was made by Clay Gomera (Drake)***
#  - Description: A simple screenshot/screencast dmenu script
#  - Dependencies: maim, splop, ffmpeg, dmenu, libnotify

###########################
## Screenshots Directory ##
###########################
SHOTDIR="$XDG_PICTURES_DIR/screenshots"
mkdir -p "$SHOTDIR"

###########################
## Screencasts Directory ##
###########################
CASTDIR="$XDG_VIDEOS_DIR/screencasts"
mkdir -p "$CASTDIR"

#######################
## Main menu choices ##
#######################
mcho1="󰹑 Take a screenshot"
mcho2="󰐍 Record the screen"
mcho3="󰙧 Stop recording"
mcho4="󱎘 Exit"
mchos="$mcho1\n$mcho2\n$mcho3\n$mcho4"

#############################
## Screenshot menu choices ##
#############################
scho1="󱣴 Entire screen"
scho2="󱎫 Entire screen with delay"
scho3="󱕻 Select area"
scho4="󰖯 Active window"
scho5="󱎘 Exit"
schos="$scho1\n$scho2\n$scho3\n$scho4\n$scho5"

########################
## Screenshot submenu ##
########################
sscho1="󰆏 Copy to clipboard"
sscho2="󰠘 Save to $SHOTDIR"
sschos="$sscho1\n$sscho2"

#################################
## Screenshot delay subsubmenu ##
#################################
del1="󱑀 3 sec delay"
del2="󱑂 5 sec delay"
del3="󱑇 10 sec delay"
dels="$del1\n$del2\n$del3"

#####
## This function uses the sschos variable to ask the user what to do with the
## screenshot
#####
fsschos() {
  sschoice=$(echo -e "$sschos" | dmenu -i -l 2 -p "  What do you want to do with this screenshot?")
}

#####
## This function uses the dels variable to ask the user which delay option to
## choose
#####
fdel() {
  del=$(echo -e "$dels" | dmenu -i -p " Select Delay")
}

#####
## This function does a full screen screenshot without delay, depending on what
## the user chooses on the fsschos function, the screenshot will be saved to the
## clipboard or to $SHOTDIR
#####
shot_screen() {
  fsschos
  if [ "$sschoice" = "$sscho1" ]; then
    maim | xclip -selection clipboard -t image/png && notify-send "Screenshot saved to clipboard"
  elif [ "$sschoice" = "$sscho2" ]; then
    maim -f jpg "$SHOTDIR/$(date +%s).jpg" && notify-send "Screenshot saved"
  else
    exit 0
  fi
}

#####
## This function does a full screen screenshot with delay, depending on what the
## user chooses on the fsschos function, the screenshot will be saved to the
## clipboard or to $SHOTDIR. And depending on what the user chooses on the fdel
## function, the delay will be between 3 and 10 seconds
#####
shot_screen_delay() {
  fsschos;
  if [ "$sschoice" = "$sscho1" ]; then
    fdel;
    case $del in
      "$del1")
        sleep 3 && maim | xclip -selection clipboard -t image/png && notify-send "Screenshot saved to clipboard";
        ;;
      "$del2")
        sleep 5 && maim | xclip -selection clipboard -t image/png && notify-send "Screenshot saved to clipboard";
        ;;
      "$del3")
        sleep 10 && maim | xclip -selection clipboard -t image/png && notify-send  "Screenshot saved to clipboard";
    esac
  elif [ "$sschoice" = "$sscho2" ]; then
    fdel;
    case $del in
      "$del1")
        sleep 3 && maim -f jpg "$SHOTDIR/$(date +%s).jpg" && notify-send "Screenshot saved to $SHOTDIR";
        ;;
      "$del2")
        sleep 5 && maim -f jpg "$SHOTDIR/$(date +%s).jpg" && notify-send "Screenshot saved to $SHOTDIR";
        ;;
      "$del3")
        sleep 10 && maim -f jpg "$SHOTDIR/$(date +%s).jpg" && notify-send "Screenshot saved to $SHOTDIR";
    esac
  else
    exit 0
  fi
}

#####
## This function allows the user to select the area on the screen to screenshot
## depending on what the user chooses on the fsschos function, the screenshot will
## be saved to the clipboard or to $SHOTDIR
#####
shot_area() {
  fsschos;
  if [ "$sschoice" = "$sscho1" ]; then
    maim -s | xclip -selection clipboard -t image/png && notify-send "Screenshot saved to clipboard";
  elif [ "$sschoice" = "$sscho2" ]; then
    maim -s -f jpg "$SHOTDIR/$(date +%s).jpg" && notify-send "Screenshot saved to $SHOTDIR";
  else
    exit 0
  fi
}

#####
## This function does a screenshot of the currently active window, depending
## on what the user chooses on the fsschos function, the screenshot will be
## saved to the clipboard or to $SHOTDIR
#####
shot_window() {
  fsschos;
  if [ "$sschoice" = "$sscho1" ]; then
    maim -i "$(xdotool getactivewindow)" | xclip -selection clipboard -t image/png && notify-send "Screenshot saved to clipboard";
  elif [ "$sschoice" = "$sscho2" ]; then
    maim -i "$(xdotool getactivewindow)" -f jpg "$SHOTDIR/$(date +%s).jpg" && notify-send "Screenshot saved to $SHOTDIR";
  else
    exit 0
  fi
}

#####
## This function uses ffmpeg to record the screen, It will check if ffmpeg is
## already running (already recording), to prevent the user from executing
## another ffmpeg instance, if it's not running, it will grab the screen
## resolution with xdpyinfo and use it to record the screen with ffmpeg.
#####
start_recording() {
  if pgrep -x "ffmpeg" > /dev/null; then
    notify-send "A screen recording is already in progress."
  else
    filename="$CASTDIR/$(date +%s).mp4"
    resolution="$(xdpyinfo | grep dimensions | awk '{print $2}')"
    ffmpeg -f x11grab -s "$resolution" -i :0.0 -c:v libx264 -preset ultrafast -qp 0 "$filename" &
    notify-send "Screen recording started."
  fi
}

#####
## This function stops screen recording, it first checks if ffmpeg is already
## running (already recording), to only stop a recording if there's an ffmpeg
## instance running
#####
stop_recording() {
  if pgrep -x "ffmpeg" > /dev/null; then
    pkill -f "ffmpeg -f x11grab"
    notify-send "Screen recording stopped. Video saved to $CASTDIR"
  else
    notify-send "You aren't recording anything at the moment"
  fi
}

##########
## main ##
##########
mchoice=$(echo -e "$mchos" | dmenu -i -l 4 -p "  Screen Capture Menu") # main menu prompt
case $mchoice in
  "$mcho1")
    schoice=$(echo -e "$schos" | dmenu -i -l 9 -p "  Screenshot Menu") # screenshot menu prompt
    case $schoice in
      "$scho1")
        shot_screen;
        ;;
      "$scho2")
        shot_screen_delay;
        ;;
      "$scho3")
        shot_area;
        ;;
      "$scho4")
        shot_window;
        ;;
      "$scho5")
        exit 0
    esac
    ;;
  "$mcho2")
    start_recording;
    ;;
  "$mcho3")
    stop_recording;
    ;;
  "$mcho4")
    exit 0;
    ;;
esac
